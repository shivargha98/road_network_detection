# -*- coding: utf-8 -*-
"""Spacenet3-Model-Road-NetworkExtraction-UNET+RESNET

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MpxplExHTpyfLJfOGl2391UXkna7AU-v
"""

!pip install keras==2.3.0
!pip install rasterio

from keras.layers import Input,BatchNormalization,Activation,Dense,Dropout
from keras.models import Model, load_model
from keras.layers import Input, BatchNormalization, Activation, Dense, Dropout,Add
from keras.layers.core import Lambda, RepeatVector, Reshape
from keras.layers.convolutional import Conv2D, Conv2DTranspose
from keras.layers.pooling import MaxPooling2D, GlobalMaxPool2D
from keras.layers.merge import concatenate, add
from keras.callbacks import EarlyStopping, ModelCheckpoint, ReduceLROnPlateau
from keras.optimizers import Adam
from keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_img
import keras
from keras import backend as K



def unet_resnet_model(input_tensor,n_filters,k_size,dropout=1):

  ##DownSampling
  input_shortcut = input_tensor

  ##1st Convlayer with Conv2D,BN,Activation
  conv1 = Conv2D(n_filters,(k_size,k_size),kernel_initializer='he_normal',padding='same')(input_tensor)
  conv1 = BatchNormalization()(conv1)
  conv1 = Activation("relu")(conv1)
  ##2nd Conv Layer with Conv2D,BN,Activation
  conv1 = Conv2D(n_filters,(k_size,k_size),kernel_initializer='he_normal',padding='same')(conv1)
  conv1 = BatchNormalization()(conv1)
  conv1 = Activation("relu")(conv1)
  ##3rd ConvLayer With Conv2D,BN only
  conv1 = Conv2D(n_filters,(k_size,k_size),kernel_initializer='he_normal',padding='same')(conv1)
  conv1 = BatchNormalization()(conv1)
  ##Residual Block
  resblock1 = Conv2D(n_filters,(1,1),kernel_initializer='he_normal',padding='same')(input_shortcut)
  resblock1 = BatchNormalization()(resblock1)
  conv1 = Add()([conv1,resblock1])
  conv1 = Activation("relu")(conv1)
  pool1 = MaxPooling2D((2,2))(conv1)
  pool1 = Dropout((dropout)/4)(pool1)
  
  input_shortcut = pool1
  ##1st ConvLayer
  conv2 = Conv2D(n_filters*2,(k_size,k_size),kernel_initializer="he_normal",padding="same")(pool1)
  conv2 = BatchNormalization()(conv2)
  conv2 = Activation("relu")(conv2)
  ##2nd ConvLayer
  conv2 = Conv2D(n_filters*2,(k_size,k_size),kernel_initializer="he_normal",padding="same")(conv2)
  conv2 = BatchNormalization()(conv2)
  conv2 = Activation("relu")(conv2)
  ###3rd ConvLayer
  conv2 = Conv2D(n_filters*2,(k_size,k_size),kernel_initializer="he_normal",padding="same")(conv2)
  conv2 = BatchNormalization()(conv2)
  ##Residual Block
  resblock2 = Conv2D(n_filters*2,(1,1),kernel_initializer="he_normal",padding="same")(input_shortcut)
  resblock2 = BatchNormalization()(resblock2)
  conv2 = Add()([conv2,resblock2])
  conv2 = Activation("relu")(conv2)
  pool2 = MaxPooling2D((2,2))(conv2)
  pool2 = Dropout((dropout)/3)(pool2)


  input_shortcut = pool2
  ##1st ConvLayer
  conv3 = Conv2D(n_filters*4,(k_size,k_size),kernel_initializer="he_normal",padding="same")(pool2)
  conv3 = BatchNormalization()(conv3)
  conv3 = Activation("relu")(conv3)
  ##2nd ConvLayer
  conv3 = Conv2D(n_filters*4,(k_size,k_size),kernel_initializer="he_normal",padding="same")(conv3)
  conv3 = BatchNormalization()(conv3)
  conv3 = Activation("relu")(conv3)
  ###3rd ConvLayer
  conv3 = Conv2D(n_filters*4,(k_size,k_size),kernel_initializer="he_normal",padding="same")(conv3)
  conv3 = BatchNormalization()(conv3)
  ##Residual Block
  resblock3 = Conv2D(n_filters*4,(1,1),kernel_initializer="he_normal",padding="same")(input_shortcut)
  resblock3 = BatchNormalization()(resblock3)
  conv3 = Add()([conv3,resblock3])
  conv3 = Activation("relu")(conv3)
  pool3 = MaxPooling2D((2,2))(conv3)
  pool3 = Dropout((dropout)/3)(pool3)

  input_shortcut = pool3
  ##1st ConvLayer
  conv4 = Conv2D(n_filters*8,(k_size,k_size),kernel_initializer="he_normal",padding="same")(pool3)
  conv4 = BatchNormalization()(conv4)
  conv4 = Activation("relu")(conv4)
  ##2nd ConvLayer
  conv4 = Conv2D(n_filters*8,(k_size,k_size),kernel_initializer="he_normal",padding="same")(conv4)
  conv4 = BatchNormalization()(conv4)
  conv4 = Activation("relu")(conv4)
  ###3rd ConvLayer
  conv4 = Conv2D(n_filters*8,(k_size,k_size),kernel_initializer="he_normal",padding="same")(conv4)
  conv4 = BatchNormalization()(conv4)
  ##Residual Block
  resblock4 = Conv2D(n_filters*8,(1,1),kernel_initializer="he_normal",padding="same")(input_shortcut)
  resblock4 = BatchNormalization()(resblock4)
  conv4 = Add()([conv4,resblock4])
  conv4 = Activation("relu")(conv4)
  pool4 = MaxPooling2D((2,2))(conv4)
  pool4 = Dropout((dropout)/3)(pool4)


  ##Middle Layer
  input_shortcut = pool4
  ##1st ConvLayer
  conv5 = Conv2D(n_filters*16,(k_size,k_size),kernel_initializer="he_normal",padding="same")(pool4)
  conv5 = BatchNormalization()(conv5)
  conv5 = Activation("relu")(conv5)
  ##2nd ConvLayer
  conv5 = Conv2D(n_filters*16,(k_size,k_size),kernel_initializer="he_normal",padding="same")(conv5)
  conv5 = BatchNormalization()(conv5)
  conv5 = Activation("relu")(conv5)
  ###3rd ConvLayer
  conv5 = Conv2D(n_filters*16,(k_size,k_size),kernel_initializer="he_normal",padding="same")(conv5)
  conv5 = BatchNormalization()(conv5)
  ##Residual Block
  resblock5 = Conv2D(n_filters*16,(1,1),kernel_initializer="he_normal",padding="same")(input_shortcut)
  resblock5 = BatchNormalization()(resblock5)
  conv5 = Add()([conv5,resblock5])
  conv5 = Activation("relu")(conv5)

  ##UpSampling
  #Uplayer1
  deconv4 = Conv2DTranspose(n_filters*8,(k_size,k_size),strides=(2,2),padding="same")(conv5)
  uconv4 = concatenate([deconv4,conv4])
  input_shortcut = uconv4
  uconv4 = Dropout((dropout)/2)(uconv4)
  #1st Layer
  uconv4 = Conv2D(n_filters*8,(k_size,k_size),kernel_initializer="he_normal",padding="same")(uconv4)
  uconv4 = BatchNormalization()(uconv4)
  uconv4 = Activation('relu')(uconv4)
  ##2nd Layer
  uconv4 = Conv2D(n_filters*8,(k_size,k_size),kernel_initializer="he_normal",padding="same")(uconv4)
  uconv4 = BatchNormalization()(uconv4)
  uconv4 = Activation('relu')(uconv4)
  #3rd Layer
  uconv4 = Conv2D(n_filters*8,(k_size,k_size),kernel_initializer="he_normal",padding="same")(uconv4)
  uconv4 = BatchNormalization()(uconv4)
  ##Resblock
  uresblock4 = Conv2D(n_filters*8,(1,1),kernel_initializer="he_normal",padding="same")(input_shortcut)
  uresblock4 = BatchNormalization()(uresblock4)
  uconv4 = Add()([uconv4,uresblock4])
  uconv4 = Activation("relu")(uconv4)
  
  ##UpLayer2
  deconv3 = Conv2DTranspose(n_filters*4,(k_size,k_size),strides=(2,2),padding="same")(uconv4)
  uconv3 = concatenate([deconv3,conv3])
  input_shortcut = uconv3
  uconv3 = Dropout((dropout)/2)(uconv3)
  #1st Layer
  uconv3 = Conv2D(n_filters*4,(k_size,k_size),kernel_initializer="he_normal",padding="same")(uconv3)
  uconv3 = BatchNormalization()(uconv3)
  uconv3 = Activation('relu')(uconv3)
  ##2nd Layer
  uconv3 = Conv2D(n_filters*4,(k_size,k_size),kernel_initializer="he_normal",padding="same")(uconv3)
  uconv3 = BatchNormalization()(uconv3)
  uconv3 = Activation('relu')(uconv3)
  #3rd Layer
  uconv3 = Conv2D(n_filters*4,(k_size,k_size),kernel_initializer="he_normal",padding="same")(uconv3)
  uconv3 = BatchNormalization()(uconv3)
  ##Resblock
  uresblock3 = Conv2D(n_filters*4,(1,1),kernel_initializer="he_normal",padding="same")(input_shortcut)
  uresblock3 = BatchNormalization()(uresblock3)
  uconv3 = Add()([uconv3,uresblock3])
  uconv3 = Activation("relu")(uconv3)
  
  ##UpLayer3
  deconv2 = Conv2DTranspose(n_filters*2,(k_size,k_size),strides=(2,2),padding="same")(uconv3)
  uconv2 = concatenate([deconv2,conv2])
  input_shortcut = uconv2
  uconv2 = Dropout((dropout)/2)(uconv2)
  #1st Layer
  uconv2 = Conv2D(n_filters*2,(k_size,k_size),kernel_initializer="he_normal",padding="same")(uconv2)
  uconv2 = BatchNormalization()(uconv2)
  uconv2 = Activation('relu')(uconv2)
  ##2nd Layer
  uconv2 = Conv2D(n_filters*2,(k_size,k_size),kernel_initializer="he_normal",padding="same")(uconv2)
  uconv2 = BatchNormalization()(uconv2)
  uconv2 = Activation('relu')(uconv2)
  #3rd Layer
  uconv2 = Conv2D(n_filters*2,(k_size,k_size),kernel_initializer="he_normal",padding="same")(uconv2)
  uconv2 = BatchNormalization()(uconv2)
  ##Resblock
  uresblock2 = Conv2D(n_filters*2,(1,1),kernel_initializer="he_normal",padding="same")(input_shortcut)
  uresblock2 = BatchNormalization()(uresblock2)
  uconv2 = Add()([uconv2,uresblock2])
  uconv2 = Activation("relu")(uconv2)

  ##UpLayer4
  deconv1 = Conv2DTranspose(n_filters*1,(k_size,k_size),strides=(2,2),padding="same")(uconv2)
  uconv1 = concatenate([conv1,deconv1])
  input_shortcut = uconv1
  uconv1 = Dropout((dropout)/2)(uconv1)
  #1st Layer
  uconv1 = Conv2D(n_filters*1,(k_size,k_size),kernel_initializer="he_normal",padding="same")(uconv1)
  uconv1 = BatchNormalization()(uconv1)
  uconv1 = Activation('relu')(uconv1)
  ##2nd Layer
  uconv1 = Conv2D(n_filters*1,(k_size,k_size),kernel_initializer="he_normal",padding="same")(uconv1)
  uconv1 = BatchNormalization()(uconv1)
  uconv1 = Activation('relu')(uconv1)
  #3rd Layer
  uconv1 = Conv2D(n_filters*1,(k_size,k_size),kernel_initializer="he_normal",padding="same")(uconv1)
  uconv1 = BatchNormalization()(uconv1)
  uresblock1 = Conv2D(n_filters*1,(1,1),kernel_initializer="he_normal",padding="same")(input_shortcut)
  uresblock1 = BatchNormalization()(uresblock1)
  uconv1 = Add()([uconv1,uresblock1])
  uconv1 = Activation("relu")(uconv1)

  output_layer = Conv2D(1, (1,1), padding="same", activation="sigmoid")(uconv1)
  model = Model(inputs=[input_tensor], outputs=[output_layer])
  return model

###############################################################################
### Jaccard
###############################################################################
def jaccard_coef(y_true, y_pred, smooth=1e-12):
    '''https://www.kaggle.com/drn01z3/end-to-end-baseline-with-u-net-keras
    # __author__ = Vladimir Iglovikov'''
    intersection = K.sum(y_true * y_pred, axis=[0, -1, -2])
    sum_ = K.sum(y_true + y_pred, axis=[0, -1, -2])

    jac = (intersection + smooth) / (sum_ - intersection + smooth)

    return K.mean(jac)

###############################################################################
def jaccard_coef_int(y_true, y_pred, smooth=1e-12):
    '''https://www.kaggle.com/drn01z3/end-to-end-baseline-with-u-net-keras
    # __author__ = Vladimir Iglovikov'''
    y_pred_pos = K.round(K.clip(y_pred, 0, 1))

    intersection = K.sum(y_true * y_pred_pos, axis=[0, -1, -2])
    sum_ = K.sum(y_true + y_pred, axis=[0, -1, -2])
    jac = (intersection + smooth) / (sum_ - intersection + smooth)
    return K.mean(jac)

###############################################################################
###############################################################################
### Manually define metrics
# define metrics from https://github.com/fchollet/keras/blob/master/keras/metrics.py
#   since for some reason keras can't always import them
###############################################################################    
def dice_coeff(y_true, y_pred):
    y_true_flat = K.flatten(y_true)
    y_pred_flat = K.flatten(y_pred)
    intersect = K.sum(y_true_flat * y_pred_flat)
    return (2. * intersect) / (K.sum(y_true_flat) + K.sum(y_pred_flat))

###############################################################################
def dice_loss(y_true, y_pred):
    return -1. * dice_coeff(y_true, y_pred)
    
###############################################################################
def mse(y_true, y_pred):
    return K.mean(K.square(K.flatten(y_pred) - K.flatten(y_true)), axis=-1)

###############################################################################
def f1_score(y_true, y_pred):
    '''https://stackoverflow.com/questions/45411902/how-to-use-f1-score-with-keras-model'''

    # Count positive samples.
    c1 = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
    c2 = K.sum(K.round(K.clip(y_pred, 0, 1)))
    c3 = K.sum(K.round(K.clip(y_true, 0, 1)))

    # If there are no true samples, fix the F1 score at 0.
    if c3 == 0:
        return 0

    # How many selected items are relevant?
    precision = c1 / c2

    # How many relevant items are selected?
    recall = c1 / c3

    # Calculate f1_score
    f1_score = 2 * (precision * recall) / (precision + recall)
    return f1_score 

###############################################################################
def f1_loss(y_true, y_pred):
    return 1. - f1_score(y_true, y_pred)

#####Binary Cross Entropy####
from keras.losses import BinaryCrossentropy
def bce(y_true,y_pred):
  binary_cross = BinaryCrossentropy()
  return binary_cross(y_true,y_pred)


##Loss Function##
def lossfunc(y_true,y_pred):
  return (0.8 * bce(y_true,y_pred) + 0.2*(1 - dice_coeff(y_true,y_pred)))

import keras
input_tensor = Input((256,256,3), name='img')
model = unet_resnet_model(input_tensor, n_filters=16,k_size=3,dropout=1)
model.compile(optimizer=keras.optimizers.Adam(learning_rate=0.001), loss= "binary_crossentropy", metrics=["accuracy"])

model.summary()

from sklearn.feature_extraction.image import extract_patches_2d
import cv2
import rasterio
import os
images_path = '/content/drive/My Drive/road_network/PS_RGB_8bit/'
masks_path = '/content/drive/My Drive/road_network/masks_2m/'
images_folder = list(os.walk('/content/drive/My Drive/road_network/PS_RGB_8bit'))[0][2]
masks_folder = list(os.walk('/content/drive/My Drive/road_network/masks_2m'))[0][2]

import matplotlib.pyplot as plt 
from skimage.util import view_as_windows
images_list = []
masks_list = []
number = 1
for i,j in zip(images_folder,masks_folder):
  print("\n -------Processing---",str(number),'of',str(len(images_folder)),"------ \n")
  step_size = 300
  print('Using Step Size = ',step_size)
  full_image_path = images_path+i
  full_mask_path = masks_path+j
  print(i,'==>>',j)
  image = cv2.imread(full_image_path)
  print('Shape of the image:',image.shape)
  print('Dtype of Image :',image.dtype)
  mask = cv2.imread(full_mask_path,0)
  mask[mask==150] = 1
  mask = mask.reshape((1300,1300,1))
  print('Shape of the mask:',mask.shape)
  print('Dtype of Mask:',mask.dtype)
  image_patches = view_as_windows(image,(256,256,3),step=step_size)
  image_patches = image_patches.reshape((image_patches.shape[0],image_patches.shape[1],256,256,3))
  print('Patches_created for {} shape of patches {}:'.format(i,(image_patches.shape[-3],image_patches.shape[-2],image_patches.shape[-1])))
  print('Number of Patches of Image: ',image_patches.shape[0])
  mask_patches = view_as_windows(mask,(256,256,1),step=step_size)
  mask_patches = mask_patches.reshape((mask_patches.shape[0],mask_patches.shape[1],256,256,1))
  print('Patches Created for {} shape of patches {}:'.format(j,(mask_patches.shape[-3],mask_patches.shape[-2],mask_patches.shape[-1])))
  print('Number of Patches for Mask :',mask_patches.shape[0])
  for k in range(0,image_patches.shape[0]):
    for l in range(0,image_patches.shape[1]):
      images_list.append(image_patches[k][l])
  for m in range(0,mask_patches.shape[0]):
    for n in range(0,mask_patches.shape[1]):
      masks_list.append(mask_patches[m][n]) 
  print("Image Patches Appended to array for :{},{}".format(i,j))   
  number = number+1

from skimage.util import view_as_windows
import matplotlib.pyplot as plt
import cv2
image = cv2.imread('/content/drive/My Drive/road_network/PS_RGB_8bit/SN3_roads_train_AOI_3_Paris_PS-RGB_img10.tif')
mask = cv2.imread('/content/drive/My Drive/road_network/masks_2m/AOI_3_Paris_PS-RGB_img10.png',0)
image_patches = view_as_windows(image,(256,256,3),300)
mask_patches = view_as_windows(mask,(256,256),300)
#image_patches = image_patches.reshape(1045,1045,256,256,3)
print(image_patches.shape)
print(mask_patches.shape)

plt.imshow(image)

np.unique(mask,return_counts=True)

plt.imshow(image_patches[0][5].reshape((256,256,3)))

plt.imshow(mask_patches[10][5])

import numpy as np
image_array = np.array(images_list)
mask_array = np.array(masks_list)
print("Shape of the image array :",image_array.shape)
print("Shape of the mask array :",mask_array.shape)

mask_array.max()

from sklearn.model_selection import train_test_split
X_train,X_valid,y_train,y_valid = train_test_split(image_array,mask_array,test_size=0.05,random_state=42)
print("Training Data Shape :",X_train.shape)
print("Training Labels Shape",y_train.shape)
print("Validation array shape :",X_valid.shape)
print("Validation lables Shape",y_valid.shape)

from keras.callbacks import ModelCheckpoint
filepath_model = '/content/drive/My Drive/Model_weight_road_network/model1_1_08_2020.h5'
checkpoint1 = ModelCheckpoint(filepath = filepath_model,monitor='val_loss',save_best_only=True,mode='min',verbose=2)
callbacks_list = [checkpoint1]

y_train.max()

results = model.fit(X_train, y_train, batch_size=32, epochs=100, callbacks=callbacks_list,
                    validation_data=(X_valid,y_valid))

from keras.models import load_model
unet_resnet = load_model('/content/drive/My Drive/Model_weight_road_network/model1_1_08_2020.h5')

plt.imshow(X_valid[55])

plt.imshow(y_valid[55].reshape(256,256))

test_image = X_valid[55].reshape(1,256,256,3)
print(test_image.shape)

predicted = unet_resnet.predict(test_image)

predicted = predicted.reshape((256,256))
plt.imshow(predicted)